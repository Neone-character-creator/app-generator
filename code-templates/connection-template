const isBoundComponent = ${isBoundComponent}
const boundProperty = ${boundProperty}; // The expression used to determine the value of binding.
const readOnly = ${readOnly}; // If this component only calculates its value, or is bound and can update it.
const valueExpression = "${values}";
const action = ${action};
const connected = connect((state, ownProps) => {
    const context = {
        $state: state,
        $model: models,
        $this: ownProps.value
    }
    const value = (()=>{
        try {
            if (isBoundComponent){
                return _.get(context, boundProperty);
            } else {
                return interpreter.interpret(boundProperty, context);
            }
        } catch(e){
            console.error(e);
            return undefined;
        }
    })();
    const options = (()=>{
        return interpreter.interpret(valueExpression, context);
        })() || [];
    return {
        options,
        context,
        value: _.isNil(value) ? "" : value
    };
}, (dispatch) => {
    return {dispatch};
}, (stateProps, dispatchProps, ownProps) => {
    var {dispatch} = dispatchProps;
    const update = readOnly ? () => {} :
        _.debounce((value) => {
            dispatch({ type: "SET", path: boundProperty, value: value});
        });
    const onClick = readOnly || !action ? () => {} :
        (action, value) => {
            dispatch({type: action, value});
        };
    const interpretedActionString = interpreter.interpret(action, stateProps.context);
    const actionTokens = interpretedActionString !== undefined ? interpretedActionString.split(" ") : ["",""];
    return {...stateProps,
        onClick: (event) => {
            onClick(actionTokens[0], actionTokens.slice(1).join(" "));
        },
        update: (event) => {
            update(event.target.value);
        }
    };
})(Component);

function determineValues(expression, state, value){
    if (!expression){
        return [];
    }
    const expressionTokens = expression.split(".");
    switch(expressionTokens[0]){
        case "model":
            return _.get(models, expressionTokens.slice(1).join("."));
        case "character":
            return _.get(state, expression, []);
    }
}

export default connected;